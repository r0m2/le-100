<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Le 100 - Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: 1px solid rgba(255, 255, 255, 0.2);
            --primary: #ff9f43;
            /* Warm Orange for actions */
            --text-main: #ffffff;
            --text-muted: #e0e0e0;
            --card-width: 65px;
            --card-height: 95px;
            --radius-main: 16px;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Poppins', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-gradient);
            color: var(--text-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            /* No scroll on body */
            display: flex;
            flex-direction: column;
        }

        /* --- VIEWS --- */
        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.4s ease;
            background: var(--bg-gradient);
            z-index: 10;
        }

        .view.active {
            opacity: 1;
            display: flex;
        }

        /* --- WELCOME & LOBBY --- */
        .title-area {
            text-align: center;
            margin-bottom: 40px;
        }

        .main-title {
            font-size: 3.5rem;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(to right, #fff, #a5b4fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .input-modern {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 50px;
            padding: 15px 25px;
            font-size: 1.2rem;
            color: #fff;
            text-align: center;
            width: 80%;
            max-width: 300px;
            margin: 10px 0;
            outline: none;
            transition: all 0.3s;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .input-modern:focus {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.02);
        }

        .btn-main {
            background: var(--primary);
            color: #fff;
            border: none;
            border-radius: 50px;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: 600;
            margin: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 159, 67, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            width: 80%;
            max-width: 300px;
        }

        .btn-main:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(255, 159, 67, 0.4);
        }

        .code-display {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: 5px;
            margin: 20px 0;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .player-list-container {
            width: 90%;
            max-width: 400px;
            background: var(--glass-bg);
            border-radius: var(--radius-main);
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-item:last-child {
            border-bottom: none;
        }

        .player-item.is-me {
            font-weight: 700;
            color: var(--primary);
        }

        /* --- GAME VIEW LAYOUT --- */
        #game-view {
            padding: 10px;
            justify-content: space-between;
            /* Top, Middle, Bottom */
        }

        /* TOP: OPPONENTS */
        .opponent-area {
            width: 100%;
            height: 80px;
            display: flex;
            justify-content: center;
            gap: 15px;
            align-items: center;
            overflow-x: auto;
            padding: 5px;
        }

        .opponent-avatar {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.6;
            transition: all 0.3s;
        }

        .opponent-avatar.active-turn {
            opacity: 1;
            transform: scale(1.1);
        }

        .avatar-circle {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: 2px solid transparent;
        }

        .opponent-avatar.active-turn .avatar-circle {
            border-color: var(--primary);
            box-shadow: 0 0 15px var(--primary);
        }

        .avatar-name {
            font-size: 0.7rem;
            margin-top: 4px;
        }

        .avatar-cards {
            font-size: 0.7rem;
            color: var(--primary);
            font-weight: bold;
        }

        /* MIDDLE: TABLE */
        .game-table {
            flex: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .total-score-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .score-label {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0.7;
        }

        .main-score {
            font-size: 5rem;
            font-weight: 700;
            line-height: 1;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        .main-score.pulse {
            transform: scale(1.2);
            color: var(--primary);
        }

        .played-card-zone {
            width: var(--card-width);
            height: var(--card-height);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(1.5);
            /* Make played card bigger */
            margin-top: 20px;
        }

        .turn-indicator {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        /* BOTTOM: HAND */
        .hand-container {
            width: 100%;
            height: 140px;
            /* Reduced specific height */
            display: flex;
            align-items: center;
            justify-content: flex-start;
            /* Start for scroll */
            overflow-x: auto;
            padding: 10px 20px;
            /* Side padding */
            gap: 10px;
            /* Spacing between cards */
            background: rgba(0, 0, 0, 0.2);
            /* Subtle bg for touch area */
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            /* Hide scrollbar */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .hand-container::-webkit-scrollbar {
            display: none;
        }

        /* CARDS */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: #fff;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            color: #333;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            position: relative;
            flex-shrink: 0;
            /* Important for scroll */
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card-top {
            font-size: 0.9rem;
            line-height: 1;
        }

        .card-center {
            font-size: 2rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .card-bottom {
            font-size: 0.9rem;
            line-height: 1;
            transform: rotate(180deg);
            text-align: left;
        }

        /* Interaction */
        .hand-card-wrapper {
            transition: transform 0.2s;
            cursor: pointer;
        }

        .hand-card-wrapper:active {
            transform: scale(0.9) translateY(5px);
        }

        /* --- PYRAMID --- */
        #pyramid-view {
            justify-content: flex-start;
            padding-top: 40px;
        }

        .pyramid-grid {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .p-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .p-card-slot {
            width: 60px;
            height: 85px;
            perspective: 600px;
        }

        .p-card-inner {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .p-card-inner.flipped {
            transform: rotateY(180deg);
        }

        .p-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .p-back {
            background: #333;
            border: 1px solid #555;
        }

        .p-front {
            background: #fff;
            transform: rotateY(180deg);
        }

        /* --- MODE SELECTION --- */
        .mode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
            max-width: 400px;
            padding: 10px;
        }

        .mode-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 120px;
        }

        .mode-card h3 {
            margin: 0 0 5px 0;
            font-size: 1rem;
        }

        .mode-card p {
            margin: 0;
            font-size: 0.7rem;
            opacity: 0.8;
            line-height: 1.2;
        }

        .mode-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.2);
        }

        .mode-classic {
            border-color: #2ecc71;
        }

        .mode-sudden {
            border-color: #e74c3c;
        }

        .mode-lava {
            border-color: #e67e22;
        }

        .mode-inflation {
            border-color: #f1c40f;
        }

        /* Game View Indicators */
        .mode-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .malus-indicator {
            font-size: 0.8rem;
            color: #ff6b6b;
            margin-top: 5px;
            font-weight: bold;
            height: 20px;
            /* fixed height layout */
        }

        /* --- MODALS --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
        }

        .modal-box {
            background: #fff;
            color: #333;
            width: 85%;
            max-width: 320px;
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .modal-box h2 {
            margin-top: 0;
            color: #1e3c72;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--primary);
            margin: 20px 0;
        }

        /* --- NOTIFICATIONS --- */
        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: #ff4757;
            color: #fff;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 10px 30px rgba(255, 71, 87, 0.5);
            z-index: 200;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
        }

        .toast.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .btn-back {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .btn-back:active {
            transform: scale(0.9);
        }
    </style>
</head>

<body>

    <!-- WELCOME VIEW -->
    <div id="welcome-view" class="view active">
        <div class="title-area">
            <h1 class="main-title">LE 100</h1>
        </div>

        <input type="text" id="my-pseudo" class="input-modern" placeholder="Ton Pseudo" maxlength="10">
        <button class="btn-main" onclick="showModeSelection()">Cr√©er Partie</button>

        <div style="margin: 15px; opacity: 0.5; font-size: 0.8rem;">ou rejoindre</div>

        <input type="text" id="room-code-input" class="input-modern" placeholder="CODE (ex: ABCD)" maxlength="4"
            style="text-transform:uppercase;">
        <button class="btn-main" style="background: #20bf6b;" onclick="joinRoom()">Rejoindre</button>
    </div>

    <!-- MODE SELECTION VIEW -->
    <div id="mode-view" class="view">
        <h2 style="margin-bottom: 20px;">CHOISIS TON MODE</h2>
        <div class="mode-grid">
            <div class="mode-card mode-classic" onclick="selectMode('CLASSIC')">
                <h3>CLASSIQUE</h3>
                <p>R√®gles standards.</p>
            </div>
            <div class="mode-card mode-sudden" onclick="selectMode('SUDDEN_DEATH')">
                <h3>MORT SUBITE</h3>
                <p>Au 1er m√©lange : Rois & Valets ne sauvent plus (+10).</p>
            </div>
            <div class="mode-card mode-lava" onclick="selectMode('LAVA')">
                <h3>SOL DE LAVE</h3>
                <p>Le score minimum monte de +25 √† chaque m√©lange.</p>
            </div>
            <div class="mode-card mode-inflation" onclick="selectMode('INFLATION')">
                <h3>INFLATION</h3>
                <p>Toutes les cartes gagnent +3 √† chaque m√©lange.</p>
            </div>
        </div>
        <button class="btn-main btn-back-home" onclick="showView('welcome')"
            style="margin-top:20px; background: transparent; border: 1px solid #fff;">Retour</button>
    </div>

    <!-- LOBBY VIEW -->
    <div id="lobby-view" class="view">
        <h3 style="opacity: 0.7; margin-bottom: 0;">CODE SALLE</h3>
        <div class="code-display" id="lobby-room-code">----</div>

        <div class="player-list-container" id="lobby-player-list">
            <!-- Populated by JS -->
        </div>

        <div id="host-controls" style="display:none; width: 100%; text-align: center;">
            <button class="btn-main" onclick="startGame()">Lancer !</button>
        </div>
        <div id="guest-msg" style="opacity: 0.6; display:none;">En attente de l'h√¥te...</div>
    </div>

    <!-- GAME VIEW -->
    <div id="game-view" class="view">
        <div class="btn-back" onclick="confirmBack()">‚Ü©</div>
        <div class="mode-badge" id="game-mode-badge">CLASSIQUE</div>

        <!-- TOP: Opponents -->
        <div class="opponent-area" id="opponent-area">
            <!-- JS will populate: Avatar circles -->
        </div>

        <!-- MIDDLE: Table -->
        <div class="game-table">
            <div class="total-score-container">
                <div class="score-label">Total</div>
                <div class="main-score" id="total-score">0</div>
                <div class="malus-indicator" id="malus-display"></div>
            </div>

            <div class="played-card-zone" id="played-card-slot">
                <!-- Drop zone -->
            </div>

            <div class="turn-indicator" id="current-player-name">
                En attente...
            </div>
        </div>

        <!-- BOTTOM: Hand -->
        <div class="hand-container" id="hand-area">
            <!-- JS will populate cards here -->
        </div>
    </div>

    <!-- PYRAMID VIEW -->
    <div id="pyramid-view" class="view">
        <div class="btn-back" onclick="confirmBack()">‚Ü©</div>
        <h2 style="margin-bottom: 0;">√âPREUVE FINALE</h2>
        <h3 id="pyramid-player-name" style="color: var(--primary); margin-top: 5px;">Joueur</h3>

        <div class="pyramid-grid" id="pyramid-container">
            <!-- JS Populated -->
        </div>

        <div id="pyramid-msg" style="margin-top: 20px; font-weight: bold; height: 30px;">
            PR√âPARE TOI
        </div>
    </div>

    <!-- MODALS & ALERTS -->
    <div id="ace-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>L'AS !</h2>
            <p>Vaut 1 ou 11 ?</p>
            <div style="display:flex; justify-content:center; gap:10px; margin-top:20px;">
                <button class="btn-main" onclick="resolveAce(1)">1</button>
                <button class="btn-main" onclick="resolveAce(11)">11</button>
            </div>
        </div>
    </div>

    <div id="king-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>LE ROI !</h2>
            <p>D√©finir le total :</p>
            <h1 id="king-slider-val" style="color:var(--primary)">50</h1>
            <input type="range" id="king-slider" min="1" max="80" value="50" oninput="updateKingSlider(this.value)">
            <button class="btn-main" onclick="resolveKing()">Valider</button>
        </div>
    </div>

    <!-- Quit Confirmation Modal -->
    <div id="quit-modal" class="modal-overlay">
        <div class="modal-box">
            <h2 style="color: var(--primary);">QUITTER ?</h2>
            <p>Tu vas retourner au menu principal.</p>
            <div style="display:flex; justify-content:center; gap:10px; margin-top:20px;">
                <button class="btn-main" style="background:#ff4757" onclick="confirmQuitAction()">OUI</button>
                <button class="btn-main" style="background:#7bed9f; color:#333;" onclick="closeQuitModal()">NON</button>
            </div>
        </div>
    </div>

    <div id="dizaine-alert" class="toast">
        DIZAINE ! üçª
    </div>

    <!-- LOGIC PRESERVED 100% -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, arrayUnion } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyBGME_ifiJ9nuK7VW0bRL9bPVR53O3iQHk",
            authDomain: "le-100-4ccc6.firebaseapp.com",
            projectId: "le-100-4ccc6",
            storageBucket: "le-100-4ccc6.firebasestorage.app",
            messagingSenderId: "929000428602",
            appId: "1:929000428602:web:f106364b4a6fdc79abd103",
            measurementId: "G-MGXH9RZ6YW"
        };

        let app, db;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase init failed. Check config.", e);
            alert("Erreur Firebase: V√©rifiez la configuration dans le code source.");
        }

        // --- GAME CONSTANTS ---
        const SUITS = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const PYRAMID_RANK_STRENGTH = {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
            'J': 11, 'Q': 12, 'K': 13, 'A': 14
        };

        // --- LOCAL STATE ---
        let localState = {
            playerId: localStorage.getItem('le100_playerId') || generateUUID(),
            roomId: null,
            pseudo: '',
            isHost: false,
            unsubscribe: null
        };
        localStorage.setItem('le100_playerId', localState.playerId);

        // --- DOM REFERENCES ---
        // (Note: Updated visual IDs mapping to preserve logic)
        const views = {
            welcome: document.getElementById('welcome-view'),
            mode: document.getElementById('mode-view'),
            lobby: document.getElementById('lobby-view'),
            game: document.getElementById('game-view'),
            pyramid: document.getElementById('pyramid-view')
        };

        const els = {
            myPseudo: document.getElementById('my-pseudo'),
            roomInputs: document.getElementById('room-code-input'),
            lobbyCode: document.getElementById('lobby-room-code'),
            lobbyList: document.getElementById('lobby-player-list'),
            hostControls: document.getElementById('host-controls'),
            guestMsg: document.getElementById('guest-msg'),
            score: document.getElementById('total-score'),
            modeBadge: document.getElementById('game-mode-badge'),
            malusDisplay: document.getElementById('malus-display'),
            playerName: document.getElementById('current-player-name'),
            tableSlot: document.getElementById('played-card-slot'),
            handArea: document.getElementById('hand-area'),
            opponentArea: document.getElementById('opponent-area'),
            dizaineAlert: document.getElementById('dizaine-alert'),
            // alertText is simplified in new design, reusing div
            alertText: document.getElementById('dizaine-alert'),
            aceModal: document.getElementById('ace-modal'),
            kingModal: document.getElementById('king-modal'),
            kingSlider: document.getElementById('king-slider'),
            kingSliderVal: document.getElementById('king-slider-val'),
            pyramidContainer: document.getElementById('pyramid-container'),
            pyramidPlayerName: document.getElementById('pyramid-player-name'),
            pyramidMsg: document.getElementById('pyramid-msg'),
            quitModal: document.getElementById('quit-modal')
        };

        // --- HELPER FUNCTIONS ---
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function generateRoomCode() {
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let result = "";
            for (let i = 0; i < 4; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
            return result;
        }

        function showView(viewName) {
            Object.values(views).forEach(v => {
                if (v) {
                    v.classList.remove('active');
                    v.style.display = 'none';
                }
            });
            if (views[viewName]) {
                views[viewName].style.display = 'flex';
                setTimeout(() => views[viewName].classList.add('active'), 10);
            }
        }

        function createDeck() {
            let deck = [];
            for (let s of SUITS) {
                for (let r of RANKS) {
                    let value = parseInt(r);
                    if (['J', 'Q', 'K'].includes(r)) value = 10;
                    if (r === 'A') value = 11;
                    deck.push({ suit: s, rank: r, value: value });
                }
            }
            return deck;
        }

        function shuffle(array) {
            let res = [...array];
            for (let i = res.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [res[i], res[j]] = [res[j], res[i]];
            }
            return res;
        }

        // --- LOBBY ACTIONS ---
        window.showModeSelection = () => {
            const pseudo = els.myPseudo.value.trim().toUpperCase();
            if (!pseudo) return alert("Choisis un pseudo !");
            showView('mode');
        };

        window.selectMode = (modeStr) => {
            createRoom(modeStr);
        };

        window.createRoom = async (selectedMode) => {
            const pseudo = els.myPseudo.value.trim().toUpperCase();
            // Pseudo check done in showModeSelection but good to keep safe
            if (!pseudo) return alert("Choisis un pseudo !");

            localState.pseudo = pseudo;
            localState.isHost = true;
            localState.roomId = generateRoomCode();

            const initialData = {
                status: 'WAITING',
                mode: selectedMode,
                reshuffleCount: 0,
                floorLevel: 0,
                inflationVal: 0,
                players: [{
                    id: localState.playerId,
                    name: pseudo,
                    hand: [],
                    isHost: true
                }],
                deck: [],
                discardPile: [],
                currentTotal: 0,
                currentPlayerIndex: 0,
                lastCardPlayed: null,
                pyramid: null,
                createdAt: new Date().toISOString()
            };

            await setDoc(doc(db, "games", localState.roomId), initialData);
            subscribeToRoom(localState.roomId);
        };

        window.joinRoom = async () => {
            const pseudo = els.myPseudo.value.trim().toUpperCase();
            const code = els.roomInputs.value.trim().toUpperCase();
            if (!pseudo || code.length !== 4) return alert("Pseudo et Code requis !");

            const roomRef = doc(db, "games", code);
            const snap = await getDoc(roomRef);

            if (!snap.exists()) return alert("Salle introuvable !");
            const data = snap.data();

            if (data.status !== 'WAITING') return alert("Partie d√©j√† en cours !");

            // Rejoin or Add
            if (!data.players.find(p => p.id === localState.playerId)) {
                if (data.players.length >= 6) return alert("Salle pleine !");
                await updateDoc(roomRef, {
                    players: arrayUnion({
                        id: localState.playerId,
                        name: pseudo,
                        hand: [],
                        isHost: false
                    })
                });
            }

            localState.pseudo = pseudo;
            localState.roomId = code;
            localState.isHost = false;
            subscribeToRoom(code);
        };

        function subscribeToRoom(roomId) {
            if (localState.unsubscribe) localState.unsubscribe();

            localState.unsubscribe = onSnapshot(doc(db, "games", roomId), (docSnap) => {
                if (docSnap.exists()) {
                    renderFromSnapshot(docSnap.data());
                }
            });
        }

        window.startGame = async () => {
            if (!localState.isHost) return;

            const roomRef = doc(db, "games", localState.roomId);
            const snap = await getDoc(roomRef);
            const data = snap.data();

            const deck = shuffle(createDeck());
            const players = [...data.players];
            const cardsPerPlayer = Math.floor(52 / players.length);

            // Simple distribution
            players.forEach(p => {
                p.hand = deck.splice(0, cardsPerPlayer);
            });

            await updateDoc(roomRef, {
                status: 'PLAYING',
                deck: deck, // Remaining
                discardPile: [],
                players: players,
                currentTotal: 0,
                currentPlayerIndex: 0,
                lastCardPlayed: null
            });
        };

        // --- RENDER LOGIC ---
        function renderFromSnapshot(data) {
            // Toast Trigger Logic
            if (!localState.lastStatus) localState.lastStatus = 'WAITING';
            if (data.status === 'PLAYING' && localState.lastStatus !== 'PLAYING') {
                let msg = "";
                switch (data.mode) {
                    case 'SUDDEN_DEATH': msg = "MODE MORT SUBITE : Au prochain m√©lange, les Rois et Valets ne sauvent plus !"; break;
                    case 'LAVA': msg = "MODE SOL DE LAVE : Le score min monte √† chaque m√©lange !"; break;
                    case 'INFLATION': msg = "MODE INFLATION : Toutes les cartes prennent +3 √† chaque m√©lange !"; break;
                    default: msg = "MODE CLASSIQUE : Bon jeu !"; break;
                }
                // Reuse dizaine alert for simplicity or create new? 
                // Using dizaine alert style for generic toast valid 3s
                els.dizaineAlert.innerText = msg;
                els.dizaineAlert.classList.add('show');
                setTimeout(() => {
                    els.dizaineAlert.classList.remove('show');
                    // Reset text
                    setTimeout(() => els.dizaineAlert.innerText = "DIZAINE ! üçª", 500);
                }, 4000);
            }
            localState.lastStatus = data.status;

            // 1. Waiting Room
            if (data.status === 'WAITING') {
                showView('lobby');
                els.lobbyCode.innerText = localState.roomId;
                els.lobbyList.innerHTML = '';
                data.players.forEach(p => {
                    let div = document.createElement('div');
                    div.className = `player-item ${p.id === localState.playerId ? 'is-me' : ''}`;
                    // Modern list item
                    div.innerHTML = `<span>${p.name}</span> ${p.isHost ? '<span style="font-size:0.8rem">üëë</span>' : ''}`;
                    els.lobbyList.appendChild(div);
                });

                if (localState.isHost) els.hostControls.style.display = 'block';
                else els.guestMsg.style.display = 'block';
                return;
            }

            // 2. Playing
            if (data.status === 'PLAYING') {
                showView('game');
                renderGameBoard(data);

                // Check for Global Events
                if (data.lastEvent && data.lastEvent.timestamp) {
                    handleGlobalEvent(data.lastEvent);
                }
                return;
            }

            // 3. Pyramid
            if (data.status === 'TRIAL') {
                showView('pyramid');
                renderPyramidSnapshot(data);
                return;
            }
        }

        function renderGameBoard(data) {
            // Mode Badge
            const modeNames = {
                'CLASSIC': 'CLASSIQUE',
                'SUDDEN_DEATH': 'MORT SUBITE',
                'LAVA': 'SOL DE LAVE',
                'INFLATION': 'INFLATION'
            };
            els.modeBadge.innerText = modeNames[data.mode] || 'CLASSIQUE';

            // Malus Indicator
            let malusText = "";
            let count = data.reshuffleCount || 0;
            switch (data.mode) {
                case 'LAVA':
                    let floor = data.floorLevel || 0;
                    malusText = `Sol: ${floor} (M√©langes: ${count})`;
                    break;
                case 'INFLATION':
                    let bonus = data.inflationVal || 0;
                    malusText = `Bonus: +${bonus} (M√©langes: ${count})`;
                    break;
                case 'SUDDEN_DEATH':
                    if (count > 0) malusText = "‚ö†Ô∏è DANGER ACTIF ‚ö†Ô∏è";
                    else malusText = "M√©langes avant Danger : 1";
                    break;
                default:
                    malusText = "";
            }
            els.malusDisplay.innerText = malusText;


            // Score
            els.score.innerText = data.currentTotal;
            if (data.lastCardPlayed) {
                // Pulse Reset
                els.score.classList.remove('pulse');
                void els.score.offsetWidth;
                els.score.classList.add('pulse');
            }

            // Current Player Indicator
            const activePlayer = data.players[data.currentPlayerIndex];
            els.playerName.innerText = `C'est √† ${activePlayer.name}`;
            if (activePlayer.id === localState.playerId) {
                els.playerName.style.color = 'var(--primary)';
                els.playerName.innerText = "√Ä TOI DE JOUER !";
            } else {
                els.playerName.style.color = '#fff';
            }

            // Last Card
            if (data.lastCardPlayed) {
                els.tableSlot.innerHTML = createCardHTML(data.lastCardPlayed, data.mode, data.inflationVal);
            } else {
                els.tableSlot.innerHTML = '';
            }

            // My Hand (Horizontal Scroll)
            els.handArea.innerHTML = '';
            const myData = data.players.find(p => p.id === localState.playerId);
            const isMyTurn = (activePlayer.id === localState.playerId);

            if (myData) {
                myData.hand.forEach((card, idx) => {
                    let cardWrapper = document.createElement('div');
                    cardWrapper.className = 'hand-card-wrapper';
                    cardWrapper.innerHTML = createCardHTML(card, data.mode, data.inflationVal);

                    if (isMyTurn) {
                        cardWrapper.onclick = () => onCardClick(idx, card);
                    } else {
                        cardWrapper.style.opacity = '0.5';
                        cardWrapper.style.pointerEvents = 'none';
                    }
                    els.handArea.appendChild(cardWrapper);
                });
            }

            // Opponents (Avatars Top)
            els.opponentArea.innerHTML = '';
            const opponents = data.players.filter(p => p.id !== localState.playerId);
            opponents.forEach((p) => {
                let isActive = (p.id === activePlayer.id);
                let div = document.createElement('div');
                div.className = `opponent-avatar ${isActive ? 'active-turn' : ''}`;

                // Avatar Circle + Info
                div.innerHTML = `
                    <div class="avatar-circle">
                        ${p.name.substring(0, 2)}
                    </div>
                    <div class="avatar-name">${p.name}</div>
                    <div class="avatar-cards">${p.hand.length} üÉè</div>
                `;
                els.opponentArea.appendChild(div);
            });
        }

        // --- GAME INTERACTION ---
        let pendingCardIdx = -1;

        function onCardClick(idx, card) {
            pendingCardIdx = idx;
            if (card.rank === 'K') {
                showModal('king');
            } else if (card.rank === 'A') {
                showModal('ace');
            } else {
                submitMove({ cardIndex: idx, val: 0, card: card });
            }
        }

        window.resolveKing = () => {
            let val = parseInt(els.kingSlider.value);
            hideModal('king');
            submitMove({ cardIndex: pendingCardIdx, val: val });
        };

        window.resolveAce = (val) => {
            hideModal('ace');
            submitMove({ cardIndex: pendingCardIdx, val: val });
        };

        // --- TRANSACTIONS ---
        async function submitMove(moveData) {
            const roomRef = doc(db, "games", localState.roomId);
            try {
                const snap = await getDoc(roomRef);
                const data = snap.data();

                if (data.players[data.currentPlayerIndex].id !== localState.playerId) return;

                const player = data.players[data.currentPlayerIndex];
                const card = player.hand[moveData.cardIndex];

                // --- MODE LOGIC: VALUE CALCULATION ---
                let val = moveData.val; // Base value (0 for non-choice cards initially)
                const isReshuffledOnce = (data.reshuffleCount && data.reshuffleCount > 0);

                // SUDDEN DEATH: Kings/Jacks lose powers after first reshuffle
                let effectiveRank = card.rank;
                if (data.mode === 'SUDDEN_DEATH' && isReshuffledOnce) {
                    if (['K', 'J'].includes(card.rank)) {
                        // Treat as simple 10
                        val = 10;
                        effectiveRank = '10'; // disable switch case special behaviors
                    }
                }

                // INFLATION: Add bonus
                let inflationBonus = (data.mode === 'INFLATION' && data.inflationVal) ? data.inflationVal : 0;

                let newTotal = data.currentTotal;

                // SPECIAL CARDS LOGIC
                // (Note: Ace and King user-choice values are passed in moveData.val)
                // We add inflationBonus to numeric additions, but not to SET values (like Jack=70) unless specific rule?
                // User requirement: "Toutes les cartes gagnent +3". 
                // Interpretation: If I play a 5, it's 5+3=8. If I play King(50), it is 50+3=53. 

                if (effectiveRank === 'J') {
                    // Jack = 70 (Fixed value, maybe inflation applies? Let's say yes for fun/consistency or no?
                    // "Cards gain +3". Usually applies to adders. 
                    // Let's apply to the final effect on total if it's additive.
                    // But Jack SETS total to 70. 
                    // Let's keep Jack = 70 STRICT, no inflation, to be safe unless specified.
                    newTotal = 70;
                }
                else if (effectiveRank === 'Q') {
                    // Queen = 0 (Total unchanged).
                    // If Inflation, maybe it adds 3? "All cards gain +3". 
                    // Let's add inflation to 0. So Queen adds 3.
                    newTotal += (0 + inflationBonus);
                }
                else if (effectiveRank === 'K') {
                    // King sets total to val (user choice). 
                    // Inflation? If I choose 50, is it 53? Yes.
                    newTotal = val + inflationBonus;
                }
                else if (effectiveRank === 'A') {
                    // Ace adds 1 or 11.
                    newTotal += (val + inflationBonus);
                }
                else {
                    // Number cards
                    let rankVal = parseInt(effectiveRank);
                    if (['10'].includes(effectiveRank)) rankVal = 10; // Handle '10' string if needed, mostly redundant
                    newTotal += (rankVal + inflationBonus);
                }

                // LAVA: Floor Check
                const floor = (data.mode === 'LAVA' && data.floorLevel) ? data.floorLevel : 0;
                newTotal = Math.max(newTotal, floor);

                player.hand.splice(moveData.cardIndex, 1);
                data.discardPile.push(card);
                data.lastCardPlayed = card;
                data.lastEvent = null; // Reset event

                if (newTotal >= 100) {
                    data.currentTotal = newTotal;
                    data.status = 'TRIAL';
                    data.pyramid = initPyramidData(player.name, player.id);
                    await updateDoc(roomRef, data);
                    return;
                }

                data.currentTotal = newTotal;

                // DIZAINE ALERT (Global)
                if (newTotal > 0 && newTotal % 10 === 0) {
                    data.lastEvent = {
                        type: 'DIZAINE',
                        player: localState.playerId,
                        timestamp: Date.now()
                    };
                }

                // Next Player Logic
                let increment = 1;
                let nextIdx = (data.currentPlayerIndex + increment) % data.players.length;

                // Skip empty hands loop
                let attempts = 0;
                while (data.players[nextIdx].hand.length === 0 && attempts < data.players.length) {
                    nextIdx = (nextIdx + 1) % data.players.length;
                    attempts++;
                }

                if (attempts >= data.players.length) {
                    data.status = 'WAITING';
                } else {
                    data.currentPlayerIndex = nextIdx;
                }

                // Resupply check & RESHUFFLE LOGIC
                let totalCards = data.players.reduce((sum, p) => sum + p.hand.length, 0);
                if (totalCards < 24 && data.discardPile.length > 0) {
                    // RESHUFFLE TRIGGER
                    // If we are actually taking from discardPile to reuse as deck
                    // The logic here originally just took discardPile as newDeck.
                    // This IS the reshuffle.

                    let newDeck = shuffle([...data.discardPile]);
                    data.discardPile = [];

                    // --- MODE EVOLUTIONS ---
                    if (!data.reshuffleCount) data.reshuffleCount = 0;
                    data.reshuffleCount++;

                    if (data.mode === 'LAVA') {
                        if (!data.floorLevel) data.floorLevel = 0;
                        data.floorLevel += 25;
                        if (data.floorLevel > 90) data.floorLevel = 90; // Cap
                    }
                    else if (data.mode === 'INFLATION') {
                        if (!data.inflationVal) data.inflationVal = 0;
                        data.inflationVal += 3;
                    }

                    // Distribute
                    let cIdx = 0;
                    while (cIdx < newDeck.length) {
                        for (let i = 0; i < data.players.length; i++) {
                            if (cIdx >= newDeck.length) break;
                            data.players[i].hand.push(newDeck[cIdx]);
                            cIdx++;
                        }
                    }
                }

                await updateDoc(roomRef, data);

            } catch (e) {
                console.error("Move failed", e);
            }
        }

        window.updateKingSlider = (val) => els.kingSliderVal.innerText = val;

        // --- GLOBAL EVENTS ---
        let lastProcessedEventTime = 0;

        function handleGlobalEvent(event) {
            if (event.timestamp <= lastProcessedEventTime) return;
            lastProcessedEventTime = event.timestamp;

            if (event.type === 'DIZAINE') {
                if (event.player !== localState.playerId) {
                    triggerDizaineAlert();
                }
            }
        }

        function triggerDizaineAlert() {
            els.dizaineAlert.classList.add('show');
            setTimeout(() => els.dizaineAlert.classList.remove('show'), 3000);
        }

        window.confirmBack = () => {
            els.quitModal.style.display = 'flex';
            setTimeout(() => els.quitModal.classList.add('visible'), 10);
        };

        window.closeQuitModal = () => {
            els.quitModal.classList.remove('visible');
            setTimeout(() => els.quitModal.style.display = 'none', 300);
        };

        window.confirmQuitAction = () => {
            window.location.reload();
        };

        // --- PYRAMID ---
        function initPyramidData(loserName, loserId) {
            let deck = shuffle(createDeck());
            let grid = [];
            for (let i = 0; i < 6; i++) {
                let count = 6 - i;
                let rowCards = [];
                for (let c = 0; c < count; c++) {
                    rowCards.push({
                        card: deck.pop(),
                        revealed: false
                    });
                }
                grid.push({ slots: rowCards });
            }
            return {
                active: true,
                loserName: loserName,
                loserId: loserId,
                grid: grid,
                deck: deck,
                currentLevel: 0,
                referenceCard: null,
                msg: "CHOISIS TA BASE"
            };
        }

        function renderPyramidSnapshot(data) {
            const pData = data.pyramid;
            els.pyramidPlayerName.innerText = pData.loserName;
            els.pyramidMsg.innerText = pData.msg;

            const isMe = (pData.loserId === localState.playerId);

            els.pyramidContainer.innerHTML = '';
            for (let i = 5; i >= 0; i--) {
                let rowEl = document.createElement('div');
                rowEl.className = 'p-row';

                pData.grid[i].slots.forEach((slot, slotIndex) => {
                    let slotDiv = document.createElement('div');
                    slotDiv.className = 'p-card-slot';

                    let isCurrentLevel = (i === pData.currentLevel);

                    // Interaction Logic (Disabled visual only, event check inside click)
                    if (!isMe || !isCurrentLevel || slot.revealed) {
                        slotDiv.style.cursor = 'default';
                        if (!slot.revealed) slotDiv.style.opacity = '0.5';
                    } else {
                        slotDiv.style.cursor = 'pointer';
                        slotDiv.onclick = () => window.onPyramidCardClick(i, slotIndex);
                    }

                    // Faces
                    let inner = document.createElement('div');
                    inner.className = `p-card-inner ${slot.revealed ? 'flipped' : ''}`;

                    let back = document.createElement('div');
                    back.className = 'p-face p-back';

                    let front = document.createElement('div');
                    let color = (slot.card.suit === '‚ô•' || slot.card.suit === '‚ô¶') ? 'red' : 'black';
                    front.className = 'p-face p-front';
                    if (color === 'red') front.style.color = 'red';
                    else front.style.color = '#333';

                    front.innerHTML = `<b>${slot.card.rank}</b> ${slot.card.suit}`;

                    inner.appendChild(back);
                    inner.appendChild(front);
                    slotDiv.appendChild(inner);
                    rowEl.appendChild(slotDiv);
                });
                els.pyramidContainer.appendChild(rowEl);
            }
        }

        // Global Lock for Pyramid Interaction
        let isProcessingPyramidClick = false;

        window.onPyramidCardClick = async (rowIndex, slotIndex) => {
            if (isProcessingPyramidClick) return;
            isProcessingPyramidClick = true;

            try {
                const roomRef = doc(db, "games", localState.roomId);
                const snap = await getDoc(roomRef);
                const data = snap.data();
                const pData = data.pyramid;

                // Validate (Double check strict logic to prevent race conditions)
                if (pData.currentLevel !== rowIndex) return; // Wrong level

                // IMPORTANT: Check if any card in this row is ALREADY revealed (Server-side check)
                if (pData.grid[rowIndex].slots[slotIndex].revealed) return; // Already revealed

                // STRICT: Ensure ONLY ONE card per row is revealed
                const isRowAlreadyRevealed = pData.grid[rowIndex].slots.some(s => s.revealed);
                if (isRowAlreadyRevealed) {
                    console.warn("Row already has a revealed card. Ignoring.");
                    return;
                }

                let slot = pData.grid[rowIndex].slots[slotIndex];
                slot.revealed = true;

                let card = slot.card;
                let rankStrength = PYRAMID_RANK_STRENGTH[card.rank];

                if (pData.referenceCard === null) {
                    pData.referenceCard = card;
                    pData.currentLevel++;
                    pData.msg = `PLUS FORT QUE ${card.rank} !`;
                } else {
                    let refStrength = PYRAMID_RANK_STRENGTH[pData.referenceCard.rank];
                    if (rankStrength > refStrength) {
                        pData.referenceCard = card;
                        if (pData.currentLevel === 5) {
                            pData.msg = "VICTOIRE !!";
                            setTimeout(async () => {
                                data.status = 'WAITING';
                                data.pyramid = null;
                                await updateDoc(roomRef, data);
                            }, 3000);
                        } else {
                            pData.currentLevel++;
                            pData.msg = `BIEN ! PLUS FORT QUE ${card.rank}`;
                        }
                    } else {
                        pData.msg = "TU BOIS !!!";
                        setTimeout(async () => {
                            punishPyramidData(pData);
                            await updateDoc(roomRef, { pyramid: pData });
                        }, 2000);
                    }
                }
                await updateDoc(roomRef, { pyramid: pData });
            } catch (e) {
                console.error("Pyramid Click Failed", e);
            } finally {
                isProcessingPyramidClick = false;
            }
        };

        function punishPyramidData(pData) {
            let failedLevel = pData.currentLevel;
            let prevLevel = failedLevel - 1;

            // Helper to get card safely (replenish if empty)
            const safePop = () => {
                if (!pData.deck || pData.deck.length === 0) {
                    pData.deck = shuffle(createDeck());
                }
                return pData.deck.pop();
            };

            pData.grid[failedLevel].slots.forEach(s => {
                if (s.revealed) {
                    s.card = safePop();
                    s.revealed = false;
                }
            });

            if (prevLevel >= 0) {
                pData.grid[prevLevel].slots.forEach(s => {
                    if (s.revealed) {
                        s.card = safePop();
                        s.revealed = false;
                    }
                });
            }

            pData.currentLevel = Math.max(0, prevLevel);
            pData.referenceCard = null;

            if (pData.currentLevel > 0) {
                let levelBelow = pData.currentLevel - 1;
                let ref = null;
                pData.grid[levelBelow].slots.forEach(s => { if (s.revealed) ref = s.card; });
                pData.referenceCard = ref;
                pData.msg = `REDESCENDU... PLUS FORT QUE ${ref ? ref.rank : '?'}`;
            } else {
                pData.msg = "RECOMMENCE (CHOISIS UNE BASE)";
            }
        }

        // --- UTILS ---
        function createCardHTML(card, mode, inflationVal) {
            let colorClass = (card.suit === '‚ô•' || card.suit === '‚ô¶') ? 'red' : 'black';
            let badge = '';

            // INFLATION VISUALIZATION
            if (mode === 'INFLATION' && inflationVal > 0) {
                let baseVal = parseInt(card.rank);
                if (!isNaN(baseVal)) {
                    // Number Cards: Show Result (e.g. "= 5")
                    badge = `<div style="position:absolute; top:55%; left:0; width:100%; text-align:center; color:#d35400; font-size:0.9rem; font-weight:bold; text-shadow: 0 0 3px white;">= ${baseVal + inflationVal}</div>`;
                } else {
                    // Face Cards
                    if (card.rank === 'Q') {
                        // Queen (0) -> inflationVal
                        badge = `<div style="position:absolute; top:55%; left:0; width:100%; text-align:center; color:#d35400; font-size:0.9rem; font-weight:bold; text-shadow: 0 0 3px white;">= ${inflationVal}</div>`;
                    } else if (['K', 'A'].includes(card.rank)) {
                        // Choice cards -> +Val
                        badge = `<div style="position:absolute; top:18%; right:2px; color:#d35400; font-size:0.7rem; font-weight:bold; background:rgba(255,255,255,0.7); border-radius:4px; padding:0 2px;">+${inflationVal}</div>`;
                    }
                    // Jack stays 70, no badge
                }
            }

            return `
            <div class="card ${colorClass}">
                <div class="card-top">${card.rank}</div>
                <div class="card-center">${card.suit}</div>
                ${badge}
                <div class="card-bottom">${card.rank}</div>
            </div>
        `;
        }

        function showModal(type) {
            const m = type === 'king' ? els.kingModal : els.aceModal;
            m.style.display = 'flex';
            setTimeout(() => m.classList.add('visible'), 10);
        }
        function hideModal(type) {
            const m = type === 'king' ? els.kingModal : els.aceModal;
            m.classList.remove('visible');
            setTimeout(() => m.style.display = 'none', 300);
        }

    </script>
</body>

</html>